{
  "type": "Program",
  "body": [],
  "sourceType": "module",
  "range": [
    36599,
    36599
  ],
  "loc": {
    "start": {
      "line": 1098,
      "column": 0
    },
    "end": {
      "line": 1098,
      "column": 0
    }
  },
  "leadingComments": [
    {
      "type": "Block",
      "value": "'use strict';\nvar Server = require('../../../lib/server');\nvar expect = require('chai').expect;\nvar Model = require('hoist-model');\nvar BBPromise = require('bluebird');\nvar mongoose = BBPromise.promisifyAll(Model._mongoose);\nvar config = require('config');\nvar sinon = require('sinon');\nvar pipeline = require('hoist-events-pipeline').Pipeline;\nvar _ = require('lodash');\n\ndescribe('Event Routes', function () {\n\n  var server;\n  before(function () {\n    server = Server.createServer();\n    return BBPromise.all([\n      mongoose.connectAsync(config.get('Hoist.mongo.db')),\n      new Model.Organisation({\n        _id: 'orgid',\n        name: 'test org',\n        slug: 'org'\n      }).saveAsync(),\n      new Model.Application({\n        _id: 'appid',\n        organisation: 'orgid',\n        name: 'test app',\n        apiKey: 'apiKey',\n        slug: 'app'\n      }).saveAsync()\n    ]);\n  });\n  after(function () {\n    return BBPromise.all([\n      Model.Organisation.removeAsync(),\n      Model.Application.removeAsync()\n    ]).then(function () {\n      return mongoose.disconnectAsync();\n    });\n  });\n  describe('GET /event/{id}', function () {\n    describe('with matching event', function () {\n      var _response;\n      var _event;\n      var clock;\n      before(function (done) {\n        clock = sinon.useFakeTimers();\n        new Model.Event({\n            eventId: 'eventid',\n            applicationId: 'appid',\n            environment: 'live'\n\n          }).saveAsync()\n          .then(function (event) {\n            _event = event;\n            server.inject({\n              method: 'GET',\n              url: '/event/eventid',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              _response = response;\n              done();\n            });\n          });\n      });\n      after(function () {\n        clock.restore();\n        return Model.Event.removeAsync();\n      });\n      it('returns the event JSON', function () {\n        expect(_response.result).to.eql(_event.toJSON());\n      });\n      it('responds with 200 OK', function () {\n        expect(_response.statusCode).to.eql(200);\n      });\n    });\n    describe('with no matching event', function () {\n\n      var _response;\n      before(function (done) {\n\n        server.inject({\n          method: 'GET',\n          url: '/event/eventid',\n          headers: {\n            authorization: 'Hoist apiKey'\n          }\n        }, function (response) {\n          _response = response;\n          done();\n\n        });\n      });\n      after(function () {\n        return Model.Event.removeAsync();\n      });\n      it('responds with a 404 NOT FOUND', function () {\n        expect(_response.statusCode).to.eql(404);\n      });\n      it('responds with descriptive message', function () {\n        expect(_response.result).to.eql({\n          statusCode: 404,\n          error: 'Not Found',\n          message: 'event not found'\n        });\n      });\n    });\n  });\n\n  describe('GET /events', function () {\n    this.timeout(20000);\n    describe('with no token', function () {\n      describe('with events in timeout', function () {\n\n        var _response;\n        var _event;\n        before(function (done) {\n          setTimeout(function () {\n            new Model.Event({\n              applicationId: 'appid',\n              environment: 'live'\n            }).saveAsync().then(function (event) {\n              _event = event;\n            });\n          }, 1000);\n          server.inject({\n            method: 'GET',\n            url: '/events?&timeoutMS=2000',\n            headers: {\n              authorization: 'Hoist apiKey'\n            }\n          }, function (response) {\n            _response = response;\n            done();\n          });\n        });\n        after(function () {\n          return BBPromise.all([\n            Model.EventToken.removeAsync(),\n            Model.Event.removeAsync()\n          ]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync()\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns an event', function () {\n          var event = _event.toJSON();\n          return expect(_response.result.events).to.eql([event]);\n        });\n        it('returns new token code', function () {\n          return expect(_response.result.token).to.exist;\n        });\n        it('responds with 201 CREATED', function () {\n          return expect(_response.statusCode).to.eql(201);\n        });\n      });\n      describe('with no events in timeout', function () {\n        describe('with valid timeoutMS in query', function () {\n          var _time;\n          var _response;\n          before(function (done) {\n            _time = Date.now();\n            server.inject({\n              method: 'GET',\n              url: '/events?timeoutMS=2000',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              response.payload = JSON.parse(response.payload);\n              _response = response;\n              done();\n            });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns no events', function () {\n            return expect(_response.result.events).to.eql([]);\n          });\n          it('returns new token code', function () {\n            return expect(_response.result.token).to.exist;\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                expect(token.lastUsed.getTime()).to.be.least(_time + 2000);\n              });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with invalid timeoutMS in query', function () {\n          var _time;\n          var _response;\n          before(function (done) {\n            _time = Date.now();\n            server.inject({\n              method: 'GET',\n              url: '/events?timeoutMS=20hgsuf00',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              response.payload = JSON.parse(response.payload);\n              _response = response;\n              done();\n            });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns no events', function () {\n            return expect(_response.result.events).to.eql([]);\n          });\n          it('returns new token code', function () {\n            return expect(_response.result.token).to.exist;\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                expect(token.lastUsed.getTime()).to.be.least(_time + 10000);\n              });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with no timeoutMS in query', function () {\n          var _time;\n          var _response;\n          before(function (done) {\n            _time = Date.now();\n            server.inject({\n              method: 'GET',\n              url: '/events',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              response.payload = JSON.parse(response.payload);\n              _response = response;\n              done();\n            });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns no events', function () {\n            return expect(_response.result.events).to.eql([]);\n          });\n          it('returns new token code', function () {\n            return expect(_response.result.token).to.exist;\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                expect(token.lastUsed.getTime()).to.be.least(_time + 10000);\n              });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n      });\n    });\n    describe('with an existing token', function () {\n      describe('with events since last use', function () {\n        describe('without filterBy in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  response.payload = JSON.parse(response.payload);\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy correlationId and no filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=correlationId',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy correlationId and filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=correlationId&filterValue=eventid',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            events = _.where(events, {\n              correlationId: 'eventid'\n            });\n            return expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            return expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            return expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy eventName and no filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=correlationId',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  response.payload = JSON.parse(response.payload);\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy eventName and filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=eventName&filterValue=eventName',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  response.payload = JSON.parse(response.payload);\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            events = _.where(events, {\n              eventName: 'eventName'\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with invalid filterBy in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=filterBy&filterValue=eventName',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            return expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            return expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            return expect(_response.statusCode).to.eql(201);\n          });\n        });\n      });\n      describe('with no events since last use', function () {\n        describe('with events in timeout', function () {\n          var _token;\n          var _response;\n          var _event;\n          before(function (done) {\n            setTimeout(function () {\n              new Model.Event({\n                applicationId: 'appid',\n                environment: 'live'\n              }).saveAsync().then(function (event) {\n                _event = event;\n              });\n            }, 1000);\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function (token) {\n                _token = token;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&timeoutMS=2000',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('returns an event', function () {\n            var event = _event.toJSON();\n            expect(_response.result.events).to.eql([event]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('resets token timeout', function () {\n            return Model.EventToken.findOneAsync({\n              code: _response.result.token\n            }).then(function (token) {\n              expect(token.lastUsed).to.be.above(_token.lastUsed);\n            });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with no events in timeout', function () {\n          var _token;\n          var _response;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function (token) {\n                _token = token;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&timeoutMS=2000',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('returns no events', function () {\n            expect(_response.result.events).to.eql([]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync({\n              code: _response.result.token\n            }).then(function (token) {\n              expect(token.lastUsed).to.be.least(_token.lastUsed.getTime() + 2000);\n            });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n      });\n    });\n    describe('with an expired token', function () {\n      describe('with events in timeout', function () {\n\n        var _response;\n        var _event;\n        before(function (done) {\n          setTimeout(function () {\n            new Model.Event({\n              applicationId: 'appid',\n              environment: 'live'\n            }).saveAsync().then(function (event) {\n              _event = event;\n            });\n          }, 1000);\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=tokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return BBPromise.all([\n            Model.EventToken.removeAsync(),\n            Model.Event.removeAsync()\n          ]);\n        });\n        it('returns an event', function () {\n          var event = _event.toJSON();\n          expect(_response.result.events).to.eql([event]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n      describe('with no events in timeout', function () {\n        var _time;\n        var _response;\n        before(function (done) {\n          _time = Date.now();\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=tokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return Model.EventToken.removeAsync();\n        });\n        it('returns no events', function () {\n          expect(_response.result.events).to.eql([]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('returns after timeout', function () {\n          return Model.EventToken.findOneAsync({\n              code: _response.result.token\n            })\n            .then(function (token) {\n              return expect(token.lastUsed.getTime()).to.be.least(_time + 2000);\n            });\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n    });\n    describe('with a non existing token', function () {\n      describe('with events in timeout', function () {\n\n        var _response;\n        var _event;\n        before(function (done) {\n          setTimeout(function () {\n            new Model.Event({\n              applicationId: 'appid',\n              environment: 'live'\n            }).saveAsync().then(function (event) {\n              _event = event;\n            });\n          }, 1000);\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=fakeTokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return BBPromise.all([\n            Model.EventToken.removeAsync(),\n            Model.Event.removeAsync()\n          ]);\n        });\n        it('returns an event', function () {\n          var event = _event.toJSON();\n          expect(_response.result.events).to.eql([event]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n      describe('with no events in timeout', function () {\n        var _time;\n        var _response;\n        before(function (done) {\n          _time = Date.now();\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=fakeTokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return Model.EventToken.removeAsync();\n        });\n        it('returns no events', function () {\n          expect(_response.result.events).to.eql([]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('returns after timeout', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              expect(token.lastUsed.getTime()).to.be.least(_time + 2000);\n            });\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n    });\n  });\n});\n",
      "range": [
        0,
        36598
      ],
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1097,
          "column": 2
        }
      }
    }
  ],
  "comments": [
    {
      "type": "Block",
      "value": "'use strict';\nvar Server = require('../../../lib/server');\nvar expect = require('chai').expect;\nvar Model = require('hoist-model');\nvar BBPromise = require('bluebird');\nvar mongoose = BBPromise.promisifyAll(Model._mongoose);\nvar config = require('config');\nvar sinon = require('sinon');\nvar pipeline = require('hoist-events-pipeline').Pipeline;\nvar _ = require('lodash');\n\ndescribe('Event Routes', function () {\n\n  var server;\n  before(function () {\n    server = Server.createServer();\n    return BBPromise.all([\n      mongoose.connectAsync(config.get('Hoist.mongo.db')),\n      new Model.Organisation({\n        _id: 'orgid',\n        name: 'test org',\n        slug: 'org'\n      }).saveAsync(),\n      new Model.Application({\n        _id: 'appid',\n        organisation: 'orgid',\n        name: 'test app',\n        apiKey: 'apiKey',\n        slug: 'app'\n      }).saveAsync()\n    ]);\n  });\n  after(function () {\n    return BBPromise.all([\n      Model.Organisation.removeAsync(),\n      Model.Application.removeAsync()\n    ]).then(function () {\n      return mongoose.disconnectAsync();\n    });\n  });\n  describe('GET /event/{id}', function () {\n    describe('with matching event', function () {\n      var _response;\n      var _event;\n      var clock;\n      before(function (done) {\n        clock = sinon.useFakeTimers();\n        new Model.Event({\n            eventId: 'eventid',\n            applicationId: 'appid',\n            environment: 'live'\n\n          }).saveAsync()\n          .then(function (event) {\n            _event = event;\n            server.inject({\n              method: 'GET',\n              url: '/event/eventid',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              _response = response;\n              done();\n            });\n          });\n      });\n      after(function () {\n        clock.restore();\n        return Model.Event.removeAsync();\n      });\n      it('returns the event JSON', function () {\n        expect(_response.result).to.eql(_event.toJSON());\n      });\n      it('responds with 200 OK', function () {\n        expect(_response.statusCode).to.eql(200);\n      });\n    });\n    describe('with no matching event', function () {\n\n      var _response;\n      before(function (done) {\n\n        server.inject({\n          method: 'GET',\n          url: '/event/eventid',\n          headers: {\n            authorization: 'Hoist apiKey'\n          }\n        }, function (response) {\n          _response = response;\n          done();\n\n        });\n      });\n      after(function () {\n        return Model.Event.removeAsync();\n      });\n      it('responds with a 404 NOT FOUND', function () {\n        expect(_response.statusCode).to.eql(404);\n      });\n      it('responds with descriptive message', function () {\n        expect(_response.result).to.eql({\n          statusCode: 404,\n          error: 'Not Found',\n          message: 'event not found'\n        });\n      });\n    });\n  });\n\n  describe('GET /events', function () {\n    this.timeout(20000);\n    describe('with no token', function () {\n      describe('with events in timeout', function () {\n\n        var _response;\n        var _event;\n        before(function (done) {\n          setTimeout(function () {\n            new Model.Event({\n              applicationId: 'appid',\n              environment: 'live'\n            }).saveAsync().then(function (event) {\n              _event = event;\n            });\n          }, 1000);\n          server.inject({\n            method: 'GET',\n            url: '/events?&timeoutMS=2000',\n            headers: {\n              authorization: 'Hoist apiKey'\n            }\n          }, function (response) {\n            _response = response;\n            done();\n          });\n        });\n        after(function () {\n          return BBPromise.all([\n            Model.EventToken.removeAsync(),\n            Model.Event.removeAsync()\n          ]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync()\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns an event', function () {\n          var event = _event.toJSON();\n          return expect(_response.result.events).to.eql([event]);\n        });\n        it('returns new token code', function () {\n          return expect(_response.result.token).to.exist;\n        });\n        it('responds with 201 CREATED', function () {\n          return expect(_response.statusCode).to.eql(201);\n        });\n      });\n      describe('with no events in timeout', function () {\n        describe('with valid timeoutMS in query', function () {\n          var _time;\n          var _response;\n          before(function (done) {\n            _time = Date.now();\n            server.inject({\n              method: 'GET',\n              url: '/events?timeoutMS=2000',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              response.payload = JSON.parse(response.payload);\n              _response = response;\n              done();\n            });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns no events', function () {\n            return expect(_response.result.events).to.eql([]);\n          });\n          it('returns new token code', function () {\n            return expect(_response.result.token).to.exist;\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                expect(token.lastUsed.getTime()).to.be.least(_time + 2000);\n              });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with invalid timeoutMS in query', function () {\n          var _time;\n          var _response;\n          before(function (done) {\n            _time = Date.now();\n            server.inject({\n              method: 'GET',\n              url: '/events?timeoutMS=20hgsuf00',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              response.payload = JSON.parse(response.payload);\n              _response = response;\n              done();\n            });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns no events', function () {\n            return expect(_response.result.events).to.eql([]);\n          });\n          it('returns new token code', function () {\n            return expect(_response.result.token).to.exist;\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                expect(token.lastUsed.getTime()).to.be.least(_time + 10000);\n              });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with no timeoutMS in query', function () {\n          var _time;\n          var _response;\n          before(function (done) {\n            _time = Date.now();\n            server.inject({\n              method: 'GET',\n              url: '/events',\n              headers: {\n                authorization: 'Hoist apiKey'\n              }\n            }, function (response) {\n              response.payload = JSON.parse(response.payload);\n              _response = response;\n              done();\n            });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns no events', function () {\n            return expect(_response.result.events).to.eql([]);\n          });\n          it('returns new token code', function () {\n            return expect(_response.result.token).to.exist;\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync()\n              .then(function (token) {\n                expect(token.lastUsed.getTime()).to.be.least(_time + 10000);\n              });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n      });\n    });\n    describe('with an existing token', function () {\n      describe('with events since last use', function () {\n        describe('without filterBy in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  response.payload = JSON.parse(response.payload);\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy correlationId and no filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=correlationId',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy correlationId and filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=correlationId&filterValue=eventid',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            events = _.where(events, {\n              correlationId: 'eventid'\n            });\n            return expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            return expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            return expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy eventName and no filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=correlationId',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  response.payload = JSON.parse(response.payload);\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with filterBy eventName and filterValue in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=eventName&filterValue=eventName',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  response.payload = JSON.parse(response.payload);\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            events = _.where(events, {\n              eventName: 'eventName'\n            });\n            expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with invalid filterBy in query', function () {\n\n          var _response;\n          var _events;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function () {\n\n                return Model.Event.createAsync([{\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventId: 'eventid1'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  correlationId: 'eventid',\n                  eventId: 'eventid2'\n                }, {\n                  applicationId: 'appid',\n                  environment: 'live',\n                  eventName: 'eventName',\n                  eventId: 'eventid3'\n                }]);\n              }).then(function (events) {\n                _events = events;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&filterBy=filterBy&filterValue=eventName',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns events stored since last use', function () {\n            var events = _.map(_events, function (event) {\n              var ev = event.toJSON();\n              return ev;\n            });\n            return expect(_response.result.events).to.deep.have.members(events);\n          });\n          it('returns the new token code', function () {\n            return expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('responds with 201 CREATED', function () {\n            return expect(_response.statusCode).to.eql(201);\n          });\n        });\n      });\n      describe('with no events since last use', function () {\n        describe('with events in timeout', function () {\n          var _token;\n          var _response;\n          var _event;\n          before(function (done) {\n            setTimeout(function () {\n              new Model.Event({\n                applicationId: 'appid',\n                environment: 'live'\n              }).saveAsync().then(function (event) {\n                _event = event;\n              });\n            }, 1000);\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function (token) {\n                _token = token;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&timeoutMS=2000',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return BBPromise.all([\n              Model.EventToken.removeAsync(),\n              Model.Event.removeAsync()\n            ]);\n          });\n          it('returns an event', function () {\n            var event = _event.toJSON();\n            expect(_response.result.events).to.eql([event]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('resets token timeout', function () {\n            return Model.EventToken.findOneAsync({\n              code: _response.result.token\n            }).then(function (token) {\n              expect(token.lastUsed).to.be.above(_token.lastUsed);\n            });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n        describe('with no events in timeout', function () {\n          var _token;\n          var _response;\n          before(function (done) {\n            new Model.EventToken({\n                application: 'appid',\n                environment: 'live',\n                code: 'tokenCode',\n                lastUsed: Date.now()\n              }).saveAsync()\n              .then(function (token) {\n                _token = token;\n                server.inject({\n                  method: 'GET',\n                  url: '/events?token=tokenCode&timeoutMS=2000',\n                  headers: {\n                    authorization: 'Hoist apiKey'\n                  }\n                }, function (response) {\n                  _response = response;\n                  done();\n                });\n              });\n          });\n          after(function () {\n            return Model.EventToken.removeAsync();\n          });\n          it('returns no events', function () {\n            expect(_response.result.events).to.eql([]);\n          });\n          it('creates a new token', function () {\n            return Model.EventToken.findOneAsync({\n                code: {\n                  $ne: 'tokenCode'\n                }\n              })\n              .then(function (token) {\n                return expect(token).to.exist;\n              });\n          });\n          it('returns the new token code', function () {\n            expect(_response.result.token).to.not.eql('tokenCode');\n          });\n          it('returns after timeout', function () {\n            return Model.EventToken.findOneAsync({\n              code: _response.result.token\n            }).then(function (token) {\n              expect(token.lastUsed).to.be.least(_token.lastUsed.getTime() + 2000);\n            });\n          });\n          it('responds with 201 CREATED', function () {\n            expect(_response.statusCode).to.eql(201);\n          });\n        });\n      });\n    });\n    describe('with an expired token', function () {\n      describe('with events in timeout', function () {\n\n        var _response;\n        var _event;\n        before(function (done) {\n          setTimeout(function () {\n            new Model.Event({\n              applicationId: 'appid',\n              environment: 'live'\n            }).saveAsync().then(function (event) {\n              _event = event;\n            });\n          }, 1000);\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=tokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return BBPromise.all([\n            Model.EventToken.removeAsync(),\n            Model.Event.removeAsync()\n          ]);\n        });\n        it('returns an event', function () {\n          var event = _event.toJSON();\n          expect(_response.result.events).to.eql([event]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n      describe('with no events in timeout', function () {\n        var _time;\n        var _response;\n        before(function (done) {\n          _time = Date.now();\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=tokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return Model.EventToken.removeAsync();\n        });\n        it('returns no events', function () {\n          expect(_response.result.events).to.eql([]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('returns after timeout', function () {\n          return Model.EventToken.findOneAsync({\n              code: _response.result.token\n            })\n            .then(function (token) {\n              return expect(token.lastUsed.getTime()).to.be.least(_time + 2000);\n            });\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n    });\n    describe('with a non existing token', function () {\n      describe('with events in timeout', function () {\n\n        var _response;\n        var _event;\n        before(function (done) {\n          setTimeout(function () {\n            new Model.Event({\n              applicationId: 'appid',\n              environment: 'live'\n            }).saveAsync().then(function (event) {\n              _event = event;\n            });\n          }, 1000);\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=fakeTokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return BBPromise.all([\n            Model.EventToken.removeAsync(),\n            Model.Event.removeAsync()\n          ]);\n        });\n        it('returns an event', function () {\n          var event = _event.toJSON();\n          expect(_response.result.events).to.eql([event]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n      describe('with no events in timeout', function () {\n        var _time;\n        var _response;\n        before(function (done) {\n          _time = Date.now();\n          new Model.EventToken({\n              application: 'appid',\n              environment: 'live',\n              code: 'tokenCode',\n              lastUsed: Date.now() - 15 * 60 * 1000\n            }).saveAsync()\n            .then(function () {\n\n              server.inject({\n                method: 'GET',\n                url: '/events?token=fakeTokenCode&timeoutMS=2000',\n                headers: {\n                  authorization: 'Hoist apiKey'\n                }\n              }, function (response) {\n                _response = response;\n                done();\n              });\n            });\n        });\n        after(function () {\n          return Model.EventToken.removeAsync();\n        });\n        it('returns no events', function () {\n          expect(_response.result.events).to.eql([]);\n        });\n        it('creates a new token', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              return expect(token).to.exist;\n            });\n        });\n        it('returns new token code', function () {\n          expect(_response.result.token).to.not.eql('tokenCode');\n        });\n        it('returns after timeout', function () {\n          return Model.EventToken.findOneAsync({\n              code: {\n                $ne: 'tokenCode'\n              }\n            })\n            .then(function (token) {\n              expect(token.lastUsed.getTime()).to.be.least(_time + 2000);\n            });\n        });\n        it('responds with 201 CREATED', function () {\n          expect(_response.statusCode).to.eql(201);\n        });\n      });\n    });\n  });\n});\n",
      "range": [
        0,
        36598
      ],
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1097,
          "column": 2
        }
      }
    }
  ]
}