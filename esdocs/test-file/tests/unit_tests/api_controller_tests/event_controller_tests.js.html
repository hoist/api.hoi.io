<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">tests/unit_tests/api_controller_tests/event_controller_tests.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/hoist/hoist-http-host.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/lib/api_controllers/bucket_controller.js~BucketController.html">BucketController</a></span></li>
<li data-ice="classDoc"><span><a href="class/lib/api_controllers/event_controller.js~EventController.html">EventController</a></span></li>
<li data-ice="classDoc"><span><a href="class/lib/api_controllers/health_check_controller.js~EventController.html">EventController</a></span></li>
<li data-ice="classDoc"><span><a href="class/lib/authentication/hoist_plugin.js~HoistAuthentication.html">HoistAuthentication</a></span></li>
<li data-ice="classDoc"><span><a href="class/lib/router.js~Router.html">Router</a></span></li>
<li data-ice="classDoc"><span><a href="class/lib/server.js~Server.html">Server</a></span></li>
</ul>
</div>



<div data-ice="functionWrap">
  <h2><a href="function/">Function</a></h2>
  <ul>
    
  <li data-ice="functionDoc"><span><a href="function/index.html#static-function-register">register</a></span></li>
</ul>
</div>

<div data-ice="variableWrap">
  <h2><a href="variable/">Variable</a></h2>
  <ul>
    
  <li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-bucketController">bucketController</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-eventController">eventController</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-eventController">eventController</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-hoistAuthentication">hoistAuthentication</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-router">router</a></span></li>
<li data-ice="variableDoc"><span><a href="variable/index.html#static-variable-server">server</a></span></li>
</ul>
</div>



<div data-ice="externalWrap">
  <h2>External</h2>
  <ul>
    
  <li data-ice="externalDoc"><span><a href="http://hapijs.com/api#server">HapiServer</a></span></li>
<li data-ice="externalDoc"><span><a href="http://hapijs.com/api#reply-interface">Reply</a></span></li>
<li data-ice="externalDoc"><span><a href="http://hapijs.com/api#request-object">Request</a></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">tests/unit_tests/api_controller_tests/event_controller_tests.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">/*&apos;use strict&apos;;
var Server = require(&apos;../../../lib/server&apos;);
var expect = require(&apos;chai&apos;).expect;
var Model = require(&apos;hoist-model&apos;);
var BBPromise = require(&apos;bluebird&apos;);
var mongoose = BBPromise.promisifyAll(Model._mongoose);
var config = require(&apos;config&apos;);
var sinon = require(&apos;sinon&apos;);
var pipeline = require(&apos;hoist-events-pipeline&apos;).Pipeline;
var _ = require(&apos;lodash&apos;);

describe(&apos;Event Routes&apos;, function () {

  var server;
  before(function () {
    server = Server.createServer();
    return BBPromise.all([
      mongoose.connectAsync(config.get(&apos;Hoist.mongo.db&apos;)),
      new Model.Organisation({
        _id: &apos;orgid&apos;,
        name: &apos;test org&apos;,
        slug: &apos;org&apos;
      }).saveAsync(),
      new Model.Application({
        _id: &apos;appid&apos;,
        organisation: &apos;orgid&apos;,
        name: &apos;test app&apos;,
        apiKey: &apos;apiKey&apos;,
        slug: &apos;app&apos;
      }).saveAsync()
    ]);
  });
  after(function () {
    return BBPromise.all([
      Model.Organisation.removeAsync(),
      Model.Application.removeAsync()
    ]).then(function () {
      return mongoose.disconnectAsync();
    });
  });
  describe(&apos;GET /event/{id}&apos;, function () {
    describe(&apos;with matching event&apos;, function () {
      var _response;
      var _event;
      var clock;
      before(function (done) {
        clock = sinon.useFakeTimers();
        new Model.Event({
            eventId: &apos;eventid&apos;,
            applicationId: &apos;appid&apos;,
            environment: &apos;live&apos;

          }).saveAsync()
          .then(function (event) {
            _event = event;
            server.inject({
              method: &apos;GET&apos;,
              url: &apos;/event/eventid&apos;,
              headers: {
                authorization: &apos;Hoist apiKey&apos;
              }
            }, function (response) {
              _response = response;
              done();
            });
          });
      });
      after(function () {
        clock.restore();
        return Model.Event.removeAsync();
      });
      it(&apos;returns the event JSON&apos;, function () {
        expect(_response.result).to.eql(_event.toJSON());
      });
      it(&apos;responds with 200 OK&apos;, function () {
        expect(_response.statusCode).to.eql(200);
      });
    });
    describe(&apos;with no matching event&apos;, function () {

      var _response;
      before(function (done) {

        server.inject({
          method: &apos;GET&apos;,
          url: &apos;/event/eventid&apos;,
          headers: {
            authorization: &apos;Hoist apiKey&apos;
          }
        }, function (response) {
          _response = response;
          done();

        });
      });
      after(function () {
        return Model.Event.removeAsync();
      });
      it(&apos;responds with a 404 NOT FOUND&apos;, function () {
        expect(_response.statusCode).to.eql(404);
      });
      it(&apos;responds with descriptive message&apos;, function () {
        expect(_response.result).to.eql({
          statusCode: 404,
          error: &apos;Not Found&apos;,
          message: &apos;event not found&apos;
        });
      });
    });
  });

  describe(&apos;GET /events&apos;, function () {
    this.timeout(20000);
    describe(&apos;with no token&apos;, function () {
      describe(&apos;with events in timeout&apos;, function () {

        var _response;
        var _event;
        before(function (done) {
          setTimeout(function () {
            new Model.Event({
              applicationId: &apos;appid&apos;,
              environment: &apos;live&apos;
            }).saveAsync().then(function (event) {
              _event = event;
            });
          }, 1000);
          server.inject({
            method: &apos;GET&apos;,
            url: &apos;/events?&amp;timeoutMS=2000&apos;,
            headers: {
              authorization: &apos;Hoist apiKey&apos;
            }
          }, function (response) {
            _response = response;
            done();
          });
        });
        after(function () {
          return BBPromise.all([
            Model.EventToken.removeAsync(),
            Model.Event.removeAsync()
          ]);
        });
        it(&apos;creates a new token&apos;, function () {
          return Model.EventToken.findOneAsync()
            .then(function (token) {
              return expect(token).to.exist;
            });
        });
        it(&apos;returns an event&apos;, function () {
          var event = _event.toJSON();
          return expect(_response.result.events).to.eql([event]);
        });
        it(&apos;returns new token code&apos;, function () {
          return expect(_response.result.token).to.exist;
        });
        it(&apos;responds with 201 CREATED&apos;, function () {
          return expect(_response.statusCode).to.eql(201);
        });
      });
      describe(&apos;with no events in timeout&apos;, function () {
        describe(&apos;with valid timeoutMS in query&apos;, function () {
          var _time;
          var _response;
          before(function (done) {
            _time = Date.now();
            server.inject({
              method: &apos;GET&apos;,
              url: &apos;/events?timeoutMS=2000&apos;,
              headers: {
                authorization: &apos;Hoist apiKey&apos;
              }
            }, function (response) {
              response.payload = JSON.parse(response.payload);
              _response = response;
              done();
            });
          });
          after(function () {
            return Model.EventToken.removeAsync();
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync()
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns no events&apos;, function () {
            return expect(_response.result.events).to.eql([]);
          });
          it(&apos;returns new token code&apos;, function () {
            return expect(_response.result.token).to.exist;
          });
          it(&apos;returns after timeout&apos;, function () {
            return Model.EventToken.findOneAsync()
              .then(function (token) {
                expect(token.lastUsed.getTime()).to.be.least(_time + 2000);
              });
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with invalid timeoutMS in query&apos;, function () {
          var _time;
          var _response;
          before(function (done) {
            _time = Date.now();
            server.inject({
              method: &apos;GET&apos;,
              url: &apos;/events?timeoutMS=20hgsuf00&apos;,
              headers: {
                authorization: &apos;Hoist apiKey&apos;
              }
            }, function (response) {
              response.payload = JSON.parse(response.payload);
              _response = response;
              done();
            });
          });
          after(function () {
            return Model.EventToken.removeAsync();
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync()
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns no events&apos;, function () {
            return expect(_response.result.events).to.eql([]);
          });
          it(&apos;returns new token code&apos;, function () {
            return expect(_response.result.token).to.exist;
          });
          it(&apos;returns after timeout&apos;, function () {
            return Model.EventToken.findOneAsync()
              .then(function (token) {
                expect(token.lastUsed.getTime()).to.be.least(_time + 10000);
              });
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with no timeoutMS in query&apos;, function () {
          var _time;
          var _response;
          before(function (done) {
            _time = Date.now();
            server.inject({
              method: &apos;GET&apos;,
              url: &apos;/events&apos;,
              headers: {
                authorization: &apos;Hoist apiKey&apos;
              }
            }, function (response) {
              response.payload = JSON.parse(response.payload);
              _response = response;
              done();
            });
          });
          after(function () {
            return Model.EventToken.removeAsync();
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync()
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns no events&apos;, function () {
            return expect(_response.result.events).to.eql([]);
          });
          it(&apos;returns new token code&apos;, function () {
            return expect(_response.result.token).to.exist;
          });
          it(&apos;returns after timeout&apos;, function () {
            return Model.EventToken.findOneAsync()
              .then(function (token) {
                expect(token.lastUsed.getTime()).to.be.least(_time + 10000);
              });
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
      });
    });
    describe(&apos;with an existing token&apos;, function () {
      describe(&apos;with events since last use&apos;, function () {
        describe(&apos;without filterBy in query&apos;, function () {

          var _response;
          var _events;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function () {

                return Model.Event.createAsync([{
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventId: &apos;eventid1&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  correlationId: &apos;eventid&apos;,
                  eventId: &apos;eventid2&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventName: &apos;eventName&apos;,
                  eventId: &apos;eventid3&apos;
                }]);
              }).then(function (events) {
                _events = events;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  response.payload = JSON.parse(response.payload);
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns events stored since last use&apos;, function () {
            var events = _.map(_events, function (event) {
              var ev = event.toJSON();
              return ev;
            });
            expect(_response.result.events).to.deep.have.members(events);
          });
          it(&apos;returns the new token code&apos;, function () {
            expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with filterBy correlationId and no filterValue in query&apos;, function () {

          var _response;
          var _events;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function () {

                return Model.Event.createAsync([{
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventId: &apos;eventid1&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  correlationId: &apos;eventid&apos;,
                  eventId: &apos;eventid2&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventName: &apos;eventName&apos;,
                  eventId: &apos;eventid3&apos;
                }]);
              }).then(function (events) {
                _events = events;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;filterBy=correlationId&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns events stored since last use&apos;, function () {
            var events = _.map(_events, function (event) {
              var ev = event.toJSON();
              return ev;
            });
            expect(_response.result.events).to.deep.have.members(events);
          });
          it(&apos;returns the new token code&apos;, function () {
            expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with filterBy correlationId and filterValue in query&apos;, function () {

          var _response;
          var _events;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function () {
                return Model.Event.createAsync([{
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventId: &apos;eventid1&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  correlationId: &apos;eventid&apos;,
                  eventId: &apos;eventid2&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventName: &apos;eventName&apos;,
                  eventId: &apos;eventid3&apos;
                }]);
              }).then(function (events) {
                _events = events;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;filterBy=correlationId&amp;filterValue=eventid&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns events stored since last use&apos;, function () {
            var events = _.map(_events, function (event) {
              var ev = event.toJSON();
              return ev;
            });
            events = _.where(events, {
              correlationId: &apos;eventid&apos;
            });
            return expect(_response.result.events).to.deep.have.members(events);
          });
          it(&apos;returns the new token code&apos;, function () {
            return expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            return expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with filterBy eventName and no filterValue in query&apos;, function () {

          var _response;
          var _events;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function () {
                return Model.Event.createAsync([{
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventId: &apos;eventid1&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  correlationId: &apos;eventid&apos;,
                  eventId: &apos;eventid2&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventName: &apos;eventName&apos;,
                  eventId: &apos;eventid3&apos;
                }]);
              }).then(function (events) {
                _events = events;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;filterBy=correlationId&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  response.payload = JSON.parse(response.payload);
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns events stored since last use&apos;, function () {
            var events = _.map(_events, function (event) {
              var ev = event.toJSON();
              return ev;
            });
            expect(_response.result.events).to.deep.have.members(events);
          });
          it(&apos;returns the new token code&apos;, function () {
            expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with filterBy eventName and filterValue in query&apos;, function () {

          var _response;
          var _events;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function () {

                return Model.Event.createAsync([{
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventId: &apos;eventid1&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  correlationId: &apos;eventid&apos;,
                  eventId: &apos;eventid2&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventName: &apos;eventName&apos;,
                  eventId: &apos;eventid3&apos;
                }]);
              }).then(function (events) {
                _events = events;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;filterBy=eventName&amp;filterValue=eventName&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  response.payload = JSON.parse(response.payload);
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns events stored since last use&apos;, function () {
            var events = _.map(_events, function (event) {
              var ev = event.toJSON();
              return ev;
            });
            events = _.where(events, {
              eventName: &apos;eventName&apos;
            });
            expect(_response.result.events).to.deep.have.members(events);
          });
          it(&apos;returns the new token code&apos;, function () {
            expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with invalid filterBy in query&apos;, function () {

          var _response;
          var _events;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function () {

                return Model.Event.createAsync([{
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventId: &apos;eventid1&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  correlationId: &apos;eventid&apos;,
                  eventId: &apos;eventid2&apos;
                }, {
                  applicationId: &apos;appid&apos;,
                  environment: &apos;live&apos;,
                  eventName: &apos;eventName&apos;,
                  eventId: &apos;eventid3&apos;
                }]);
              }).then(function (events) {
                _events = events;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;filterBy=filterBy&amp;filterValue=eventName&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns events stored since last use&apos;, function () {
            var events = _.map(_events, function (event) {
              var ev = event.toJSON();
              return ev;
            });
            return expect(_response.result.events).to.deep.have.members(events);
          });
          it(&apos;returns the new token code&apos;, function () {
            return expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            return expect(_response.statusCode).to.eql(201);
          });
        });
      });
      describe(&apos;with no events since last use&apos;, function () {
        describe(&apos;with events in timeout&apos;, function () {
          var _token;
          var _response;
          var _event;
          before(function (done) {
            setTimeout(function () {
              new Model.Event({
                applicationId: &apos;appid&apos;,
                environment: &apos;live&apos;
              }).saveAsync().then(function (event) {
                _event = event;
              });
            }, 1000);
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function (token) {
                _token = token;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;timeoutMS=2000&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return BBPromise.all([
              Model.EventToken.removeAsync(),
              Model.Event.removeAsync()
            ]);
          });
          it(&apos;returns an event&apos;, function () {
            var event = _event.toJSON();
            expect(_response.result.events).to.eql([event]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns the new token code&apos;, function () {
            expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;resets token timeout&apos;, function () {
            return Model.EventToken.findOneAsync({
              code: _response.result.token
            }).then(function (token) {
              expect(token.lastUsed).to.be.above(_token.lastUsed);
            });
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
        describe(&apos;with no events in timeout&apos;, function () {
          var _token;
          var _response;
          before(function (done) {
            new Model.EventToken({
                application: &apos;appid&apos;,
                environment: &apos;live&apos;,
                code: &apos;tokenCode&apos;,
                lastUsed: Date.now()
              }).saveAsync()
              .then(function (token) {
                _token = token;
                server.inject({
                  method: &apos;GET&apos;,
                  url: &apos;/events?token=tokenCode&amp;timeoutMS=2000&apos;,
                  headers: {
                    authorization: &apos;Hoist apiKey&apos;
                  }
                }, function (response) {
                  _response = response;
                  done();
                });
              });
          });
          after(function () {
            return Model.EventToken.removeAsync();
          });
          it(&apos;returns no events&apos;, function () {
            expect(_response.result.events).to.eql([]);
          });
          it(&apos;creates a new token&apos;, function () {
            return Model.EventToken.findOneAsync({
                code: {
                  $ne: &apos;tokenCode&apos;
                }
              })
              .then(function (token) {
                return expect(token).to.exist;
              });
          });
          it(&apos;returns the new token code&apos;, function () {
            expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
          });
          it(&apos;returns after timeout&apos;, function () {
            return Model.EventToken.findOneAsync({
              code: _response.result.token
            }).then(function (token) {
              expect(token.lastUsed).to.be.least(_token.lastUsed.getTime() + 2000);
            });
          });
          it(&apos;responds with 201 CREATED&apos;, function () {
            expect(_response.statusCode).to.eql(201);
          });
        });
      });
    });
    describe(&apos;with an expired token&apos;, function () {
      describe(&apos;with events in timeout&apos;, function () {

        var _response;
        var _event;
        before(function (done) {
          setTimeout(function () {
            new Model.Event({
              applicationId: &apos;appid&apos;,
              environment: &apos;live&apos;
            }).saveAsync().then(function (event) {
              _event = event;
            });
          }, 1000);
          new Model.EventToken({
              application: &apos;appid&apos;,
              environment: &apos;live&apos;,
              code: &apos;tokenCode&apos;,
              lastUsed: Date.now() - 15 * 60 * 1000
            }).saveAsync()
            .then(function () {

              server.inject({
                method: &apos;GET&apos;,
                url: &apos;/events?token=tokenCode&amp;timeoutMS=2000&apos;,
                headers: {
                  authorization: &apos;Hoist apiKey&apos;
                }
              }, function (response) {
                _response = response;
                done();
              });
            });
        });
        after(function () {
          return BBPromise.all([
            Model.EventToken.removeAsync(),
            Model.Event.removeAsync()
          ]);
        });
        it(&apos;returns an event&apos;, function () {
          var event = _event.toJSON();
          expect(_response.result.events).to.eql([event]);
        });
        it(&apos;creates a new token&apos;, function () {
          return Model.EventToken.findOneAsync({
              code: {
                $ne: &apos;tokenCode&apos;
              }
            })
            .then(function (token) {
              return expect(token).to.exist;
            });
        });
        it(&apos;returns new token code&apos;, function () {
          expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
        });
        it(&apos;responds with 201 CREATED&apos;, function () {
          expect(_response.statusCode).to.eql(201);
        });
      });
      describe(&apos;with no events in timeout&apos;, function () {
        var _time;
        var _response;
        before(function (done) {
          _time = Date.now();
          new Model.EventToken({
              application: &apos;appid&apos;,
              environment: &apos;live&apos;,
              code: &apos;tokenCode&apos;,
              lastUsed: Date.now() - 15 * 60 * 1000
            }).saveAsync()
            .then(function () {

              server.inject({
                method: &apos;GET&apos;,
                url: &apos;/events?token=tokenCode&amp;timeoutMS=2000&apos;,
                headers: {
                  authorization: &apos;Hoist apiKey&apos;
                }
              }, function (response) {
                _response = response;
                done();
              });
            });
        });
        after(function () {
          return Model.EventToken.removeAsync();
        });
        it(&apos;returns no events&apos;, function () {
          expect(_response.result.events).to.eql([]);
        });
        it(&apos;creates a new token&apos;, function () {
          return Model.EventToken.findOneAsync({
              code: {
                $ne: &apos;tokenCode&apos;
              }
            })
            .then(function (token) {
              return expect(token).to.exist;
            });
        });
        it(&apos;returns new token code&apos;, function () {
          expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
        });
        it(&apos;returns after timeout&apos;, function () {
          return Model.EventToken.findOneAsync({
              code: _response.result.token
            })
            .then(function (token) {
              return expect(token.lastUsed.getTime()).to.be.least(_time + 2000);
            });
        });
        it(&apos;responds with 201 CREATED&apos;, function () {
          expect(_response.statusCode).to.eql(201);
        });
      });
    });
    describe(&apos;with a non existing token&apos;, function () {
      describe(&apos;with events in timeout&apos;, function () {

        var _response;
        var _event;
        before(function (done) {
          setTimeout(function () {
            new Model.Event({
              applicationId: &apos;appid&apos;,
              environment: &apos;live&apos;
            }).saveAsync().then(function (event) {
              _event = event;
            });
          }, 1000);
          new Model.EventToken({
              application: &apos;appid&apos;,
              environment: &apos;live&apos;,
              code: &apos;tokenCode&apos;,
              lastUsed: Date.now() - 15 * 60 * 1000
            }).saveAsync()
            .then(function () {

              server.inject({
                method: &apos;GET&apos;,
                url: &apos;/events?token=fakeTokenCode&amp;timeoutMS=2000&apos;,
                headers: {
                  authorization: &apos;Hoist apiKey&apos;
                }
              }, function (response) {
                _response = response;
                done();
              });
            });
        });
        after(function () {
          return BBPromise.all([
            Model.EventToken.removeAsync(),
            Model.Event.removeAsync()
          ]);
        });
        it(&apos;returns an event&apos;, function () {
          var event = _event.toJSON();
          expect(_response.result.events).to.eql([event]);
        });
        it(&apos;creates a new token&apos;, function () {
          return Model.EventToken.findOneAsync({
              code: {
                $ne: &apos;tokenCode&apos;
              }
            })
            .then(function (token) {
              return expect(token).to.exist;
            });
        });
        it(&apos;returns new token code&apos;, function () {
          expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
        });
        it(&apos;responds with 201 CREATED&apos;, function () {
          expect(_response.statusCode).to.eql(201);
        });
      });
      describe(&apos;with no events in timeout&apos;, function () {
        var _time;
        var _response;
        before(function (done) {
          _time = Date.now();
          new Model.EventToken({
              application: &apos;appid&apos;,
              environment: &apos;live&apos;,
              code: &apos;tokenCode&apos;,
              lastUsed: Date.now() - 15 * 60 * 1000
            }).saveAsync()
            .then(function () {

              server.inject({
                method: &apos;GET&apos;,
                url: &apos;/events?token=fakeTokenCode&amp;timeoutMS=2000&apos;,
                headers: {
                  authorization: &apos;Hoist apiKey&apos;
                }
              }, function (response) {
                _response = response;
                done();
              });
            });
        });
        after(function () {
          return Model.EventToken.removeAsync();
        });
        it(&apos;returns no events&apos;, function () {
          expect(_response.result.events).to.eql([]);
        });
        it(&apos;creates a new token&apos;, function () {
          return Model.EventToken.findOneAsync({
              code: {
                $ne: &apos;tokenCode&apos;
              }
            })
            .then(function (token) {
              return expect(token).to.exist;
            });
        });
        it(&apos;returns new token code&apos;, function () {
          expect(_response.result.token).to.not.eql(&apos;tokenCode&apos;);
        });
        it(&apos;returns after timeout&apos;, function () {
          return Model.EventToken.findOneAsync({
              code: {
                $ne: &apos;tokenCode&apos;
              }
            })
            .then(function (token) {
              expect(token.lastUsed.getTime()).to.be.least(_time + 2000);
            });
        });
        it(&apos;responds with 201 CREATED&apos;, function () {
          expect(_response.statusCode).to.eql(201);
        });
      });
    });
  });
});
*/
</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.1.4)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
